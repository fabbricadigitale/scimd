// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package core

import (
	"encoding/json"
	"errors"
	"io/ioutil"
	"sync"
)

type repositoryResourceType struct {
	items map[string]ResourceType
	mu    sync.RWMutex
}

// ResourceTypeRepository is the ...
type ResourceTypeRepository interface {
	Get(key string) *ResourceType // (fixme) > evaluate whether make senses to do not return a pointer ...
	Add(filename string) (ResourceType, error)
	List() []ResourceType
}

// List returns all elements
func (repo *repositoryResourceType) List() []ResourceType {
	repo.mu.RLock()
	defer repo.mu.RUnlock()
	res := make([]ResourceType, len(repo.items))
	i := 0
	for _, elem := range repo.items {
		res[i] = elem
		i++
	}

	return res
}

// Get provides the element for a given key, or nil if it does not exist within the repository.
func (repo *repositoryResourceType) Get(key string) *ResourceType {
	repo.mu.RLock()
	defer repo.mu.RUnlock()
	if item, ok := repo.items[key]; ok {
		return &item
	}
	return nil
}

// Add allows to load an element and to store it within this repository
func (repo *repositoryResourceType) Add(filename string) (ResourceType, error) {
	var data ResourceType

	bytes, err := ioutil.ReadFile(filename)
	if err != nil {
		return data, err
	}
	err = json.Unmarshal(bytes, &data)
	if err != nil {
		return data, err
	}

	repo.mu.Lock()
	defer repo.mu.Unlock()

	var id string
	if id = interface{}(data).(Identifiable).GetIdentifier(); id == "" {
		return data, errors.New("missing identifier")
	}

	repo.items[id] = data

	return data, nil
}

var (
	repoResourceType *repositoryResourceType
	onceResourceType sync.Once
)

// GetResourceTypeRepository is a singleton repository for core schemas
func GetResourceTypeRepository() ResourceTypeRepository {
	onceResourceType.Do(func() {
		repoResourceType = &repositoryResourceType{
			items: make(map[string]ResourceType),
		}
	})

	return repoResourceType
}
